# TBD: resolve ICS vs MOSAIC coords (search for FIX)
#  Note -- this comes up for camera focus; currently hardcoded -- fix

####
# Mod's: change so that multiple grating/angle info can be entered:
# 1. Set number  must be input per line
# 1a. Along with set number must be specified: grating, initial mu, ybar, order
# 2. solution: for each SET: solve for mu, yaw, tip, focus
# 4. For SYSTEM: solve coll (2 values), xy_opt, camerr, C2 C4, ccd_rot [cam_ang]

# MSOLVE: solve multi sets of pt/wavelength-pixel pairs to produce system params
#

include <imhdr.h>
include <math.h>
include <math/iminterp.h>
include "instrument.h"

define		SZ_GRNM	16	# size in char of grating name in header
define		ID_CHSZ	16		# Character size of ID string

define		NORD	7	# "order" of fit to derivatives

# Grating/focus params (always solved)
define	GY	3
define	GZ	4
define	GX	2
define	CF	1
define	GL	5
define	GO	6

# Detector params
define	DX	1
define	DY	2
define	DZ	3

# System params (optionally fit)
define	LT	1
define	LP	2

define	CA	3
define	CP	4

define	MX	5
define	MY	6
define	MZ	7

define	NOPTVAR	7		# 7 optical system
define	NCCDVAR	24
define	NSYSVAR	31		# NOPTVAR + NCCDVAR


procedure t_msolve ()

char	input[SZ_FNAME]			# slit info file
char	output[SZ_FNAME]		# output extraction info
char	newfile[SZ_FNAME]		# opt. rewrite of input w/ resid
char	setinfo[SZ_FNAME]		# gratings table
# char	zmapname[SZ_FNAME]		# zeta-map name
char	grating[SZ_GRNM]		# name of grating
int	niter				# number of interations

#
pointer	fda, fdb, fdd			# file descriptor for in/output files
pointer	fds				# file descriptor for data set

real	ccd[NCCD,3]			# CCD geometry
double	sys[NPARAM]			# system params

int	nslit				# No. slits
pointer	bufxmm				# pointer to slit x
pointer	bufymm				# pointer to slit y 
pointer	bufwav				# pointer to wavelength
pointer	bufx, bufy			# pointers to x,y (pixel) meas'd values
pointer	bufxp, bufyp			# pointers to x,y (pixel) predicted
pointer	bufset, bufpar			# pointers to dataset no., params
int	nset, nv
pointer	bufmat, bufpdx, bufpdy		# pointers to matrix array, partials
pointer	bufdel				# pointer to del-corrections
pointer	buffix				# pointer to fix/(vary) flag
real	grangle, roll, yaw, lines
int	order
int	npairs

char	tchar
int	ndx
int	i, j, m
int	off
int	iset

bool	rewrite
real	maxdev
real	dx, dy, dxmax, dymax, ds, dsmax
pointer	fdc

# real	relscale				# relative scale of 2 vectors
real	rmsx, rmsy

pointer	bufsq, bufsn

bool	strne()
int	access() 
int	fscan(), nscan()
int	clgeti()
real	clgetr()
pointer	open()

begin

# Read in parameters:
	call clgstr ("input", input, SZ_FNAME)
	fda = open (input, READ_ONLY, TEXT_FILE)

	call clgstr ("setinfo", setinfo, SZ_FNAME)
	fds = open (setinfo, READ_ONLY, TEXT_FILE)

# check for rewritten intput file
	call clgstr ("new_input", newfile, SZ_FNAME)
	rewrite = strne (newfile, "")
	if (rewrite) {
	    if (access (newfile, 0, 0) == YES) {
		call eprintf ("newfile file %s exists!\n")
			call pargstr (newfile, SZ_FNAME)
		call fatal (0, "")
	    } else {
		fdc = open (newfile, NEW_FILE, TEXT_FILE)
	    }
	    maxdev = clgetr ("max_dev")
	}

#	call clgstr ("inst_config.sm2zeta", zmapname, SZ_FNAME)
#	if (access (zmapname, READ_ONLY, TEXT_FILE) == YES) {
#		fdz = open (zmapname, READ_ONLY, TEXT_FILE)
#	} else {
#		call fatal (0, "Cannot open zeta-map file! \n")
#	}

#	Y_BIN(sys) = 1.			# TMP !!

	COL_ERR(sys) = DEGTORAD(clgetr ("trace.coll_angle"))
	COL_PHI(sys) = DEGTORAD(clgetr ("trace.coll_phi"))

TNT_ANG(sys) = DEGTORAD(71.5 + 0.)
TNT_PHI(sys) = DEGTORAD(90. + 0.)

	CAM_ANG(sys) = DEGTORAD(clgetr ("trace.cam_angle"))
	CAM_PHI(sys) = DEGTORAD(clgetr ("trace.cam_phi"))

	CAM_FOC(sys) = clgetr ("trace.cam_foc")

	X_OPT(sys) = clgetr ("trace.x_optaxis")
	Y_OPT(sys) = clgetr ("trace.y_optaxis")
	MOS_ROT(sys) = DEGTORAD(clgetr ("trace.mos_rotation"))

do i = 1, NCCD {
	CN_XERR(sys,i) = 0.
	CN_YERR(sys,i) = 0.
	CN_RERR(sys,i) = 0.
}

	niter = clgeti ("niter")

# Ready to deal with the data sets now:
# count the entries in the table table
	ndx = 0
	while (fscan (fds) != EOF) {
		call gargwrd (tchar, 1)
		if (tchar == '#') {
			next
		}
		ndx = ndx + 1
	}
	call seek (fds, BOF)

	call malloc (bufpar, ndx*6, TY_DOUBLE)

# count the entries in the table table
	ndx = 0
	nset = 0
	while (fscan (fds) != EOF) {
		call gargwrd (tchar, 1)
		if (tchar == '#') {
			next
		}
		call reset_scan()

		call gargi (iset)
		if (iset != nset+1)
			call eprintf ("Alignment error!!\n")

		call gargwrd (grating, SZ_GRNM)
		call gargr (grangle)
		call gargr (roll  )
		call gargr (yaw   )
		call gargr (lines )
		call gargi (order )
		call gargi (npairs)
		if (nscan() < 8)
			next
		if (npairs <= 0) {
			nset = nset + 1
			next
		}
	
		off = nset * 6 - 1
		Memd[bufpar+GX+off] = DEGTORAD(grangle)
		Memd[bufpar+GY+off] = DEGTORAD(roll)
		Memd[bufpar+GZ+off] = DEGTORAD(yaw)
		Memd[bufpar+GO+off] = order
		Memd[bufpar+GL+off] = lines
		Memd[bufpar+CF+off] = CAM_FOC(sys)
		nset = nset + 1
		ndx = ndx + npairs
call eprintf ("Set %2d: %16s (%4.0f/mm, order=%02d) %6.3f %6.3f %6.3f %5d %4d\n")
call pargi (nset)
call pargstr (grating)
call pargr (lines)
call pargi (order)
call pargr (grangle)
call pargr (roll)
call pargr (yaw)
call pargi (npairs)
call pargi (ndx)
	}


# Allocate arrays
	call malloc (bufxmm, ndx, TY_DOUBLE)
	call malloc (bufymm, ndx, TY_DOUBLE)
	call malloc (bufwav, ndx, TY_DOUBLE)
	call malloc (bufx,   ndx, TY_REAL)
	call malloc (bufy,   ndx, TY_REAL)
	call malloc (bufxp,  ndx, TY_REAL)
	call malloc (bufyp,  ndx, TY_REAL)
	call malloc (bufset, ndx, TY_INT)	# which data "set"

# Get the features:
	ndx = 0
	while (fscan (fda) != EOF) {
		call gargwrd (tchar, 1)
		if (tchar == '#')
			next
		call reset_scan()

		call gargi (Memi[bufset+ndx])
		call gargd (Memd[bufxmm+ndx])
		call gargd (Memd[bufymm+ndx])
		call gargd (Memd[bufwav+ndx])
		call gargr (Memr[bufx  +ndx])
		call gargr (Memr[bufy  +ndx])

		if (nscan() < 6)
			next
		if (Memr[bufx+ndx] == INDEF || Memr[bufy+ndx] == INDEF)
			next
		
		ndx = ndx + 1
	}
	call close (fdb)
	nslit = ndx

call eprintf ("Number of pairs: %d\n")
call pargi (nslit)



# Allocate arrays for solution:
	nv = NSYSVAR + 4 * nset
	call malloc (bufmat, nv*(nv+1), TY_DOUBLE)
	call malloc (bufpdx, (nv+1), TY_REAL)
	call malloc (bufpdy, (nv+1), TY_REAL)
	call malloc (bufdel, nv, TY_REAL)
	call malloc (buffix, nv, TY_INT)
	call amovki (NO, Memi[buffix], nv)

# TMP! FIX!
	call amulkd (Memd[bufwav], 0.0001D0, Memd[bufwav], nslit)

# Now solve for image geometry:
	call multi_solve (Memd[bufxmm], Memd[bufymm], Memd[bufwav],
	Memr[bufx], Memr[bufy], Memr[bufxp],
	Memr[bufyp], nslit, niter, ccd, sys, rmsx, rmsy, nset,
	Memd[bufpar], Memi[bufset], Memd[bufmat], Memr[bufpdx], Memr[bufpdy],
	Memr[bufdel], Memi[buffix], nv, nv+1)

# Calculate stats per set
# NB -- forced "set number" here too: FIX!?
	call calloc (bufsn, nset, TY_REAL)
	call calloc (bufsq, nset, TY_REAL)
	do i = 0, nslit-1 {
		j = Memi[bufset+i] - 1
		dx = Memr[bufxp+i] - Memr[bufx+i]
		dy = Memr[bufyp+i] - Memr[bufy+i]
		Memr[bufsq+j] = Memr[bufsq+j] + dx*dx + dy*dy
		Memr[bufsn+j] = Memr[bufsn+j] + 1.
	}
	do j = 0, nset-1 {
		call printf ("Set %2d: %6.2f px rms (n=%.0f)\n")
			call pargi (j+1)
			call pargr (sqrt (Memr[bufsq+j] / Memr[bufsn+j]))
			call pargr (Memr[bufsn+j])
	}
	call mfree (bufsn, TY_REAL)
	call mfree (bufsq, TY_REAL)

# Print out the input file w/ resids, or just the max resids:
	dxmax = 0.
	dymax = 0.
	dsmax = 0.
	if (rewrite) {
	    do i = 0, nslit-1 {
		dx = Memr[bufxp+i] - Memr[bufx+i]
		dy = Memr[bufyp+i] - Memr[bufy+i]
		ds = sqrt (dx*dx + dy*dy)
		dxmax = max (dxmax, abs (dx))
		dymax = max (dymax, abs (dy))
		dsmax = max (dsmax, ds)

		call fprintf (fdc,
		   "%2s %03d  %7.3f %7.3f  %8.2f  %7.2f %7.2f  # %4.1f %4.1f\n")
		if (ds > maxdev)
			call pargstr ("##")
		else
			call pargstr ("  ")
		call pargi (Memr[bufset+i])
		call pargd (Memd[bufxmm+i])
		call pargd (Memd[bufymm+i])
		call pargd (Memd[bufwav+i])
		call pargr (Memr[bufx+i])
		call pargr (Memr[bufy+i])
		call pargr (dx)
		call pargr (dy)
	    }
	    call close (fdc)
	} else {
	    do i = 0, nslit-1 {
		dx = Memr[bufxp+i] - Memr[bufx+i]
		dy = Memr[bufyp+i] - Memr[bufy+i]
		ds = sqrt (dx*dx + dy*dy)
		dxmax = max (dxmax, abs (dx))
		dymax = max (dymax, abs (dy))
		dsmax = max (dsmax, ds)
	    }
	}

	call eprintf (" Max differences %5.2fx %5.2fy  %5.2ftot\n")
		call pargr (dxmax)
		call pargr (dymax)
		call pargr (dsmax)


# All OK, so open the output file
	call clgstr ("output", output, SZ_FNAME)
	if (access (output, 0, 0) == YES) {
		call eprintf ("output file %s exists!\n")
			call pargstr (output, SZ_FNAME)
		call fatal (0, "")
	}
	fdd = open (output, NEW_FILE, TEXT_FILE)


# Write output file:
#	call fprintf (fdd, "# Zeta Map:       %s\n")
#		call pargstr (zmapname)

	call fprintf (fdd, "# Info file: %s\n")
		call pargstr (setinfo)

	call fprintf (fdd, "# (Solved) parameters:\n")

	call fprintf (fdd, "#  COL_ERR =%10.5f\t(%s)\n")
		call pargd (RADTODEG (COL_ERR(sys)))
	    if (Memi[buffix-1+LT] == NO)
		call pargstr ("solved")
	    else
		call pargstr ("fixed")

	call fprintf (fdd, "#  COL_PHI =%10.5f\t(%s)\n")
		call pargd (RADTODEG (COL_PHI(sys)))
	    if (Memi[buffix-1+LP] == NO)
		call pargstr ("solved")
	    else
		call pargstr ("fixed")

	call fprintf (fdd, "#  CAM_ANG =%10.5f\t\n")
		call pargd (RADTODEG (CAM_ANG(sys)))
	    if (Memi[buffix-1+CA] == NO)
		call pargstr ("solved")
	    else
		call pargstr ("fixed")

	call fprintf (fdd, "#  CAM_PHI =%10.5f\t(%s)\n")
		call pargd (RADTODEG (CAM_PHI(sys)))
	    if (Memi[buffix-1+CP] == NO)
		call pargstr ("solved")
	    else
		call pargstr ("fixed")

	call fprintf (fdd, "#  X_OPT =%7.1f\t(%s)\n")
		call pargd (X_OPT(sys))
	    if (Memi[buffix-1+MX] == NO)
		call pargstr ("solved")
	    else
		call pargstr ("fixed")

	call fprintf (fdd, "#  Y_OPT =%7.1f\t(%s)\n")
		call pargd (Y_OPT(sys))
	    if (Memi[buffix-1+MY] == NO)
		call pargstr ("solved")
	    else
		call pargstr ("fixed")

	call fprintf (fdd, "#  MOS_ROT =%10.5f\t(%s)\n")
		call pargd (RADTODEG (MOS_ROT(sys)))
	    if (Memi[buffix-1+MZ] == NO)
		call pargstr ("solved")
	    else
		call pargstr ("fixed")

	call fprintf (fdd, "#  CCDGEOM (%s):\n")
	    if (Memi[buffix-1+MZ] == NO)
		call pargstr ("solved")
	    else
		call pargstr ("fixed")
	do m = 1, NCCD {
		call fprintf (fdd, "#  %2d: %7.2fx  %7.2fy  %7.2f deg\n")
			call pargi (m)
			call pargd (CN_XERR(sys,m))
			call pargd (CN_YERR(sys,m))
			call pargd (RADTODEG(CN_RERR(sys,m)))
	}

	do m = 1, nset {
		off = (m - 1) * 6 - 1
		MU(sys)      = Memd[bufpar+GX+off]
		GR_YERR(sys) = Memd[bufpar+GY+off]
		GR_ZERR(sys) = Memd[bufpar+GZ+off]
		CAM_FOC(sys) = Memd[bufpar+CF+off]

		call fprintf (fdd,
		"# %2d:  MU= %8.5f;  ROLL= %8.5f;  YAW= %8.5f;  FOC= %7.3f\n")
			call pargi (m)
			call pargd (RADTODEG (MU(sys)))
			call pargd (RADTODEG (GR_YERR(sys)))
			call pargd (RADTODEG (GR_ZERR(sys)))
			call pargd (CAM_FOC(sys))
	}

	call fprintf (fdd, "# rmsx=%5.3f rmsy=%5.3f\n")
		call pargr (rmsx)
		call pargr (rmsy)

	call fprintf (fdd, "#\n# xmeas ymeas   xpred ypred    xmm  ymm  wave\n")

	do i = 0, nslit-1 {
		call fprintf (fdd, "%7.2f %7.2f    %7.2f %7.2f   #  %7.3f %7.3f %7.2f  %2d\n")
		call pargr (Memr[bufx+i])
		call pargr (Memr[bufy+i])
		call pargr (Memr[bufxp+i])
		call pargr (Memr[bufyp+i])
		call pargd (Memd[bufxmm+i])
		call pargd (Memd[bufymm+i])
		call pargd (Memd[bufwav+i])
		call pargi (Memr[bufset+i])
	}
	call close (fdd)


# Release memory
	call mfree (buffix, TY_INT)
	call mfree (bufdel, TY_REAL)
	call mfree (bufpdx, TY_REAL)
	call mfree (bufpdy, TY_REAL)
	call mfree (bufmat, TY_DOUBLE)
	call mfree (bufset, TY_INT)
	call mfree (bufpar, TY_DOUBLE)
	call mfree (bufyp, TY_REAL)
	call mfree (bufxp, TY_REAL)
	call mfree (bufy, TY_REAL)
	call mfree (bufx, TY_REAL)
	call mfree (bufwav, TY_DOUBLE)
	call mfree (bufymm, TY_DOUBLE)
	call mfree (bufxmm, TY_DOUBLE)
end


#########################################################
## SUBROUTINES FOLLOW:
################################################

#
# MULTI_SOLVE: accumlate and perform fit
#

procedure multi_solve (xs, ys, w, xobs, yobs, x, y, nslit, niter, ccd, sys, rmsx, rmsy, nset, spar, setndx, mat, px, py, del, fix, nv, nc)

double	xs[nslit], ys[nslit]		# SM coords of points
double	w[nslit]			# wavelength
real	xobs[nslit], yobs[nslit]	# observed pixel locations
real	x[nslit], y[nslit]		# returned best-fit positions
int	nslit				# number of slits
int	niter				# number of iterations
real	ccd[NCCD,3]			# CCD geometry
double	sys[NPARAM]			# system params
real	rmsx, rmsy			# returned rms values
#
int	nset				# number of data sets
double	spar[6,nset]			# "set" data
int	setndx[nslit]
double	mat[nc,nv]
real	px[nc], py[nc]			# partials
real	del[nv]				# corrections
int	fix[nv]				# hold variable fixed?
int	nv, nc				# nvar, nvar+1

double	e1[3,3], a2[3,3], a3[3,3], a4[3,3]	# transforms
int	n				# CCD number

pointer	asi					# pointer to interp. fit

int	i, j, k, nn, m
int	ndx
real	delang, delpix, delfoc
real	delta
real	sumx, sumy
real	wtx, wty

pointer	sfx, sfy

bool	solve_geom		# solve mosaic geometry?

int	mosim_coord()
bool	clgetb()
int	btoi()
begin

# Set limits for delta's --> also used for partials: vinc = 2.*delpar / (NORD-1)
delang = 0.006	# 0.007
delfoc = 0.30	# 0.5
delpix = 30		# 50.


## START TO FIX THE VARIABLES!

fix[LT] = btoi (!(clgetb ("vlt")))
fix[LP] = btoi (!(clgetb ("vlp")))
fix[CA] = btoi (!(clgetb ("vca")))
fix[CP] = btoi (!(clgetb ("vcp")))
fix[MX] = btoi (!(clgetb ("vmx")))
fix[MY] = btoi (!(clgetb ("vmy")))
fix[MZ] = btoi (!(clgetb ("vmz")))

solve_geom = btoi (clgetb ("vdg"))

if (solve_geom) {
	do m = NOPTVAR+1, NSYSVAR
		fix[m] = NO
} else {
	do m = NOPTVAR+1, NSYSVAR
		fix[m] = YES
}


# If the order is 0, fix the YAW variable
	do m = 1, nset {
		if (spar[GO,m] == 0.) {
			ndx = (m-1) * 4 + NSYSVAR
			fix[GZ+ndx] = YES
		}
	}


	call asiinit (asi, II_POLY5)


	call eprintf ("\n  COL_ERR COL_PHI CM_ANG  CM_PHI  X_OPT  Y_OPT  ROT  rmsx rmsy\n")

	do nn = 1, niter {
	    call amovkd (double(0.), mat, nv*nc)
	    rmsx = 0.
	    rmsy = 0.
		sumx = 0.
		sumy = 0.

	    do k = 1, nslit {

# Assign values appropriate to set:
		m = setndx[k]
		MU(sys) = spar[GX,m]
		GR_YERR(sys) = spar[GY,m]
		GR_ZERR(sys) = spar[GZ,m]
		CAM_FOC(sys) = spar[CF,m]
		ORDER(sys) = spar[GO,m]
		GRLINES(sys) = spar[GL,m]

# Evaluate the function and residuals:
		call setup (e1, a2, a3, a4, ccd, sys)
		call pt_xfm (xs[k], ys[k], w[k], e1, a2, a3, a4, ccd, sys, x[k], y[k], n)
		if (mosim_coord(x[k], y[k], n) == OFF_CHIP) {
			x[i] = abs (x[i])
			y[i] = abs (y[i])
			next
		}
		px[nc] = xobs[k] - x[k]
		py[nc] = yobs[k] - y[k]
		sumx = sumx + px[nc]
		sumy = sumy + py[nc]
		rmsx = rmsx + px[nc] * px[nc]
		rmsy = rmsy + py[nc] * py[nc]

# Solve partials (note some of these are done analytically):
		call numderiv (COL_ERR(sys), delang, xs[k], ys[k], w[k], asi,
			px[LT], py[LT], ccd, sys, e1, a2, a3, a4, fix[LT])

		call numderiv (COL_PHI(sys), delang, xs[k], ys[k], w[k], asi,
			px[LP], py[LP], ccd, sys, e1, a2, a3, a4, fix[LP])

		call numderiv (CAM_ANG(sys), delang, xs[k], ys[k], w[k], asi,
			px[CA], py[CA], ccd, sys, e1, a2, a3, a4, fix[CA])

		call numderiv (CAM_PHI(sys), delang, xs[k], ys[k], w[k], asi,
			px[CP], py[CP], ccd, sys, e1, a2, a3, a4, fix[CP])

# These are technically not true, but close enough:
		if (fix[MX] == NO)		# X_OPT
			px[MX] = 1.
		else
			px[MX] = 0.
		py[MX] = 0.

		if (fix[MY] == NO)		# Y_OPT
			py[MY] = 1.
		else
			py[MY] = 0.
		px[MY] = 0.

		call numderiv (MOS_ROT(sys), delang, xs[k], ys[k], w[k], asi,
			px[MZ], py[MZ], ccd, sys, e1, a2, a3, a4, fix[MZ])

# Now for the CCD params (all zero except for chip n):
		call amovkr (0., px[NOPTVAR+1], NCCDVAR)
		call amovkr (0., py[NOPTVAR+1], NCCDVAR)
		if (solve_geom && n != 3) {
		    ndx = (n-1)*3 + NOPTVAR
		    px[DX+ndx] = 1.
		    py[DX+ndx] = 0.
		    px[DY+ndx] = 0.
		    py[DY+ndx] = 1.
		    call numderiv (CN_RERR(sys,n), delang, xs[k], ys[k], w[k],
	asi, px[DZ+ndx], py[DZ+ndx], ccd, sys, e1, a2, a3, a4, fix[DZ+ndx])
		}
			
			
# Below are set-specific; most are zero ...
		call amovkr (0., px[NSYSVAR+1], nset*4)
		call amovkr (0., py[NSYSVAR+1], nset*4)

# ... but some are not
		ndx = (m-1) * 4 + NSYSVAR

# FIX FIX!!!  TMP HARDCODES!
## FIX fix[CF] never defined...
fix[CF+ndx] = NO
		if (fix[CF+ndx] == NO) {	#CAM_FOC
			px[CF+ndx] = (x[k] - 4120 - X_OPT(sys)) / CAM_FOC(sys)
			py[CF+ndx] = (y[k] - 4096 - Y_OPT(sys)) / CAM_FOC(sys)
		} else {
			px[CF+ndx] = 0.
			py[CF+ndx] = 0.
		}

		call numderiv (MU(sys), delang, xs[k], ys[k], w[k], asi,
		px[GX+ndx], py[GX+ndx], ccd, sys, e1, a2, a3, a4, fix[GX+ndx])

		call numderiv (GR_YERR(sys), delang, xs[k], ys[k], w[k], asi,
		px[GY+ndx], py[GY+ndx], ccd, sys, e1, a2, a3, a4, fix[GY+ndx])

		call numderiv (GR_ZERR(sys), delang, xs[k], ys[k], w[k], asi,
		px[GZ+ndx], py[GZ+ndx], ccd, sys, e1, a2, a3, a4, fix[GZ+ndx])

### FIX!  The following seems to be some weighting scheme
# Accumulate data in matrix:
		wtx = 1. #+ abs (x[k] - X_OPT(sys)) / 512.
		wty = 1. #+ exp (-1.* (x[k] - X_OPT(sys))**2 / 512.) + abs (y[k] - Y_OPT(sys)) / 1024.
		wtx = wtx #* 4.

		do j = 1, nv {
		    do i = 1, nc {
#call eprintf ("%d:px[%d]=%f, py[%d]=%f\n")
#call pargi (j)
#call pargi (i)
#call pargr (px[i])
#call pargi (i)
#call pargr (py[i])
			mat[i,j] = mat[i,j] + wtx*(px[i] * px[j]) + wty*(py[i] * py[j])
		    }
		}
	    }
# Remove FIXED variables from fit
	    do j = 1, nv {
		if (fix[j] == YES) {
			mat[j, j] = mat[j, j] + 1.
			mat[nc,j] = mat[nc,j] + 0.
		}
	    }
# Solve matrix (getting _BIG_!)
	    call g2_elim (mat, nv)

## TMP -- 0.9/0.6 is cooling
	    delta = mat[nc,LT]
	    del[LT] = 0.6 * max (min (delta, delang), -delang)

	    delta = mat[nc,LP]
	    del[LP] = 0.9 * max (min (delta, delang), -delang)

	    delta = mat[nc,CA]
	    del[CA] = 0.9 * max (min (delta, delang), -delang)

	    delta = mat[nc,CP]
	    del[CP] = 0.9 * max (min (delta, delang), -delang)

	    delta = mat[nc,MX]
	    del[MX] = 0.6 * max (min (delta, delpix), -delpix)

	    delta = mat[nc,MY]
	    del[MY] = 0.6 * max (min (delta, delpix), -delpix)

	    delta = mat[nc,MZ]
	    del[MZ] = 0.9 * max (min (delta, delang), -delang)

# CCD specific
	    if (solve_geom) {
		do m = 1, NCCD {
		    ndx = (m-1)*3 + NOPTVAR

		    delta = mat[nc,DX+ndx]
		    del[DX+ndx] = 0.9 * max (min (delta, delpix), -delpix)
		    delta = mat[nc,DY+ndx]
		    del[DY+ndx] = 0.9 * max (min (delta, delpix), -delpix)
		    delta = mat[nc,DZ+ndx]
		    del[DZ+ndx] = 0.9 * max (min (delta, delang), -delang)
		}
	    } else {
		do m = 1, NCCD {
		    ndx = (n-1)*3 + NOPTVAR
		    del[DX+ndx] = 0.
		    del[DY+ndx] = 0.
		    del[DZ+ndx] = 0.
		}
	    } 

# Set-specific
	    do m = 1, nset {
		ndx = (m-1) * 4 + NSYSVAR

		delta = mat[nc,GX+ndx]
		del[GX+ndx] = 0.9 * max (min (delta, delang), -delang)

		delta = mat[nc,GY+ndx]
		del[GY+ndx] = 0.9 * max (min (delta, delang), -delang)

		delta = mat[nc,GZ+ndx]
		del[GZ+ndx] = 0.9 * max (min (delta, delang), -delang)

		delta = mat[nc,CF+ndx]
		del[CF+ndx] = 0.9 * max (min (delta, delfoc), -delfoc)
# call eprintf ("DEBUG!:  %d  %6f %6f %6f %6f\n")
# call pargi (ndx)
# call pargr (del[GX+ndx])
# call pargr (del[GY+ndx])
# call pargr (del[GZ+ndx])
# call pargr (del[CF+ndx])
	    }

# TMP!  This could be cleaner, avoiding any calc if held fixed.
# Set fixed variable to zero delta
	    do j = 1, nv {
		if (fix[j] == YES)
			del[j] = 0.
	    }

	    rmsx = sqrt (rmsx / nslit)
	    rmsy = sqrt (rmsy / nslit)

	    call eprintf ( "%2d %6.3f %6.3f %6.3f %6.3f %5.0f %5.0f %6.3f %5f %5f\n")
		call pargi (nn)
		call pargd (RADTODEG (COL_ERR(sys)))
		call pargd (RADTODEG (COL_PHI(sys)))
		call pargd (RADTODEG (CAM_ANG(sys)))
		call pargd (RADTODEG (CAM_PHI(sys)))
		call pargd (X_OPT(sys))
		call pargd (Y_OPT(sys))
		call pargd (RADTODEG (MOS_ROT(sys)))
		call pargr (rmsx)
		call pargr (rmsy)

if (niter == 1)		# assume update is not desired!
	break

# Update parameters
	    COL_ERR(sys) = COL_ERR(sys) + del[LT]
	    COL_PHI(sys) = COL_PHI(sys) + del[LP]
	    CAM_ANG(sys) = CAM_ANG(sys) + del[CA]
	    CAM_PHI(sys) = CAM_PHI(sys) + del[CP]
	    X_OPT(sys)   = X_OPT(sys)   + del[MX]
	    Y_OPT(sys)   = Y_OPT(sys)   + del[MY]
	    MOS_ROT(sys) = MOS_ROT(sys) + del[MZ]

# REVIEW: above sets del=0 for no solve; can remove this if()
	    if (solve_geom) {
		do m = 1, NCCD {
		    if (m == 3)				# Chip 3 is fiducial
			next
		    ndx = (m-1)*3 + NOPTVAR
		    CN_XERR(sys,m) = CN_XERR(sys,m) + del[DX+ndx]
		    CN_YERR(sys,m) = CN_YERR(sys,m) + del[DY+ndx]
		    CN_RERR(sys,m) = CN_RERR(sys,m) + del[DZ+ndx]
		}
	    }

	    do m = 1, nset {
		ndx = (m-1) * 4 + NSYSVAR
		spar[CF,m] = spar[CF,m] + del[CF+ndx]
		spar[GX,m] = spar[GX,m] + del[GX+ndx]
		spar[GY,m] = spar[GY,m] + del[GY+ndx]
		if (spar[GO,m] == 0.)
			del[GZ+ndx] = 0.
		spar[GZ,m] = spar[GZ,m] + del[GZ+ndx]
	    }
	}

# Free work vectors
call eprintf ("avg: %f %f\n")
call pargr (sumx / nslit)
call pargr (sumy / nslit)
	call gsfree (sfy)
	call gsfree (sfx)
	call asifree (asi)

end




#
# G2_ELIM: procedure for gaussian elimination, n var's; double prec.
# (copy)

procedure g2_elim (a, n)

double	a[n+1,n]			# matrix to be solved
int	n				# number of variables

int	i, j, k
double	den, hold

begin
	do k = 1, n {
		den = a[k,k]
		if (den == 0.) {		# look for non-zero: switch
			do j = (k+1), n {
				if (a[k,k] != 0.) {
					do i = k, (n+1) {
						hold = a[i,j]
						a[i,j] = a[i,k]
						a[i,k] = hold
					}
				den = a[k,k]
				}
			}
			if (den == 0.)			# if still zero, skip
				next
		}
		do i = k, (n+1)
			a[i,k] = a[i,k] / den
		do j = 1, n
			if (j != k) {
				den = a[k,j]
				do i = k, (n+1)
					a[i,j] = a[i,j] - a[i,k] * den
			}
	}
end

procedure numderiv (varpar, delpar, xs, ys, w, asi, px, py, ccd, sys, e1, a2, a3, a4, fixed)

double	varpar				# system parameter to vary 
real	delpar				# amount to vary parameter
double	xs, ys				# x,y on slit (mm)
double	w				# ref wavelength
pointer	asi				# pointer to fit structure
real	px, py				# partials in x, y
real	ccd[NCCD,3]			# CCD geometry
double	sys[NPARAM]			# system parameters for pt_xfm
double	e1[3,3], a2[3,3], a3[3,3], a4[3,3]	# transforms
int	fixed				# Is parameter fixed?

int	n			# CCD number

int	i
int	noff
double	par0				# original value (must be restored!)
real	vinc, v0
real	x[NORD], y[NORD]		# work arrays

real	deriv[2]

int	mosim_coord()
begin
# Check to see if anything must be done:
	if (fixed == YES) {
		px = 0.
		py = 0.
		return
	}

# store parameter
	par0 = varpar

	vinc = 2. * delpar / (NORD - 1)
	noff = NORD / 2
	v0 = -vinc * (noff +1) + varpar
	do i = 1, NORD {
		varpar = v0 + vinc * i
		call setup (e1, a2, a3, a4, ccd, sys)
		call pt_xfm (xs, ys, w, e1, a2, a3, a4, ccd, sys, x[i], y[i], n)
		if (mosim_coord(x[i], y[i], n) == OFF_CHIP) {
			x[i] = abs (x[i])
			y[i] = abs (y[i])
		}
	}

	call asifit (asi, x, NORD)
	call asider (asi, real (noff+1), deriv, 2)
	px = deriv[2] / vinc
	
	call asifit (asi, y, NORD)
	call asider (asi, real (noff+1), deriv, 2)
	py = deriv[2] / vinc

# Restore parameter:
	varpar = par0
end

