# REFL: Test the reflection algorithm

include	<math.h>

procedure	t_refl()

double	tx, ty
double	zx, zy

real	clgetr()

begin
	tx = clgetr ("tx")
	ty = clgetr ("ty")
	zx = clgetr ("zx")
	zy = clgetr ("zy")

	call printf ("Inp angles: %f %f; normal at %f %f \n")
		call pargd (tx)
		call pargd (ty)
		call pargd (zx)
		call pargd (zy)

	tx = DEGTORAD (tx)
	ty = DEGTORAD (ty)
	zx = DEGTORAD (zx)
	zy = DEGTORAD (zy)

	call refl (tx, ty, zx, zy)

	tx = RADTODEG (tx)
	ty = RADTODEG (ty)

	call eprintf ("New angles: %f %f \n")
		call pargd (tx)
		call pargd (ty)

end

procedure	refl (tx, ty, zx, zy)

double	tx, ty
double	zx, zy

double	phi, theta
double	phin, thetan
double	tanx, tany
double	cost, sint, cosp, sinp
double	x, y, z
double	xp, yp, zp

begin
# CALC x,y,z
	phi = atan2 (sin (ty), sin (tx))
	tanx = tan (tx)
	tany = tan (ty)
	theta = atan (sqrt (tanx*tanx + tany*tany))

	cosp = cos (phi)
	sinp = sin (phi)
	cost = cos (theta)
	sint = sin (theta)

	x = cosp * sint
	y = sinp * sint
	z = cost

	phin = PI - atan2 (sin (zx), sin (zy))
	tanx = tan (zx)
	tany = tan (zy)
	thetan = atan (sqrt (tanx*tanx + tany*tany))

	cosp = cos (phin)
	sinp = sin (phin)
	cost = cos (thetan)
	sint = sin (thetan)

#	 cosp		 sinp		0
#	-cost*sinp	 cost*cosp	sint
#	 sint*sinp	-sint*cosp	cost
	
	xp = x*(      cosp) + y*(      sinp)
	yp = x*(-cost*sinp) + y*( cost*cosp) + z*sint
	zp = x*( sint*sinp) + y*(-sint*cosp) + z*cost

# Now the magic; negate xp,yp and retransform ...

	xp = -xp
	yp = -yp

	x = xp*(      cosp) + yp*(-cost*sinp) + zp*( sint*sinp)
	y = xp*(      sinp) + yp*( cost*cosp) + zp*(-sint*cosp)
	z =                   yp*( sint     ) + zp*( cost)

	tx = atan2 (x, z)
	ty = atan2 (y, z)
end
