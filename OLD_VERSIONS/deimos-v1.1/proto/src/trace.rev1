# TRACE: Trace mask points through DEIMOS
# NOTES: redefined p3 & GRATING XFM currently redefined for pure roll, but
# eventually probably want to return to old system as phi3 is probably a
# constant to be solved for

include	<math.h>

# define	D_1	20023.15D0
# define	R_CURV	2071.88D0
define	D_1	20018.4D0	# see deimos.h PPLDIST
define	R_CURV	2124.71D0	# ditto; r=83.65in in this case = R_IMSURF

define	NCCD	9	# last = image CS

procedure	t_trace()

char	input[SZ_FNAME]			# input file name (x,y,w)
double	t1, p1
double	t2, p2
double	t3, p3, o3
pointer	fda

real	clgetr()
pointer	open()

begin
	t1 = clgetr ("t1")
	p1 = clgetr ("p1")
	t2 = clgetr ("t2")
	p2 = clgetr ("p2")
	t3 = clgetr ("t3")
	p3 = clgetr ("p3")
	o3 = clgetr ("o3")

	call clgstr ("input", input, SZ_FNAME)
        fda = open (input, READ_ONLY, TEXT_FILE)

	call setup2 (fda, t1, p1, t2, p2, t3, p3, o3)

	call close (fda)

end

procedure	setup2 (fda, t1, p1, t2, p2, t3, p3, o3)

pointer	fda		# file descriptor for input file
double	t1, p1		# theta, phi of normal 1
double	t2, p2		# theta, phi of normal 2
double	t3, p3, o3	# theta, phi of normal 3

double	r[3]
real	ccd[NCCD,3]	
double	a1[3,3], a2[3,3], a3[3,3], a4[3,3]
double	e1[3,3], e2[3,3], e3[3,3], e4[3,3]

double	phi, theta
double	phin, thetan
double	cost, sint, cosp, sinp
double	xsi, cosx, sinx
double	rhon
double	cosr, sinr

double	x, y, pa
double	alpha, beta, gamma
real	xpix, ypix
double	rp, hm
double	tx, ty	# TMP!

int	n
int	mx, my			# location in mosaic

real	ord
real	foclen
double	space, w
double	roll3

int	ident_ccd()
int	clgeti()
int	fscan(), nscan()
real	clgetr()

begin
	foclen = clgetr ("foc_len")
	roll3 = clgetr ("roll3")
	ord = clgeti ("norder")
	space = 1000. / clgeti ("gmm")
	call printf ("# ord=%2f  space=%5f  tilt=%-6.2f  phi=%-8.4f  roll=%-7.4f yaw=%-7.4f\n")
		call pargr (ord)
		call pargd (space)
		call pargd (t3)
		call pargd (p3)
		call pargd (roll3)
		call pargd (o3)
	call printf ("#  t1=%6.4f p1=%8.4f   t2=%7.4f p2=%8.4f \n")
		call pargd (t1)
		call pargd (p1)
		call pargd (t2)
		call pargd (p2)

# COLL ERROR (first order):
# In this case, we must remove the phi we put in, hence the more complex form
	thetan = DEGTORAD(2.*t1)
	phin = DEGTORAD(p1) + HALFPI
	cosp = cos (phin)
	sinp = sin (phin)
	cost = cos (thetan)
	sint = sin (thetan)

	e1[1,1] =  1 - (1-cost)*sinp*sinp	# cosp*cosp + cost*sinp*sinp
	e1[1,2] =  (1-cost) * cosp*sinp
	e1[1,3] = -sinp*sint
	e1[2,1] =  (1-cost) * cosp*sinp
	e1[2,2] =  1 - (1-cost)*cosp*cosp	# sinp*sinp + cost*cosp*cosp
	e1[2,3] =  cosp*sint
	e1[3,1] =  sint*sinp
	e1[3,2] = -sint*cosp
	e1[3,3] =  cost


# TENT MIRROR:
# this mirror is OK to leave in del-theta,phi
	thetan = DEGTORAD(71.5 + t2)
	phin = DEGTORAD(90. + p2) + HALFPI
	cosp = cos (phin)
	sinp = sin (phin)
	cost = cos (thetan)
	sint = sin (thetan)

	a2[1,1] = cosp
	a2[1,2] = sinp
	a2[1,3] = 0.
	a2[2,1] = -cost*sinp
	a2[2,2] = cost*cosp
	a2[2,3] = sint
	a2[3,1] = sint*sinp
	a2[3,2] = -sint*cosp
	a2[3,3] = cost

# MIRROR/GRATING:
# Better in thetax, thetay description (see above)
# for GRATING: need to add the third rotation
# Note the hack with phin + PI.  This is needed to keep the transformed
# x, y axes from flipping, wrt the original x,y.  Not a problem wrt reflections
# but if we want to work _within_ a system it is a problem. Cf. camera also
# note that this _forces_ us to work in a particular hemisphere, and thus we
# must make use of the negative theta as needed.

	thetan = DEGTORAD(t3)
	phin = DEGTORAD(p3) + HALFPI
	xsi = DEGTORAD(o3)
	if (p3 > 0.) {
		phin = phin + PI
		thetan = -thetan
	}
	cosp = cos (phin)
	sinp = sin (phin)
	cost = cos (thetan)
	sint = sin (thetan)
	cosx = cos (xsi)
	sinx = sin (xsi)

	a3[1,1] =  cosx*cosp - cost*sinp*sinx	#  cosp
	a3[1,2] =  cosx*sinp + cost*cosp*sinx	#  sinp
	a3[1,3] =  sinx*sint			#  0.
	a3[2,1] = -sinx*cosp - cost*sinp*cosx	# -cost*sinp
	a3[2,2] = -sinx*sinp + cost*cosp*cosx	#  cost*cosp
	a3[2,3] =  cosx*sint			#  sint
	a3[3,1] =  sint*sinp
	a3[3,2] = -sint*cosp
	a3[3,3] =  cost


	thetan = -DEGTORAD(t3)
	phin = 0.

#	cosp = 1.
#	sinp = 0.
	cost = cos (thetan)
	sint = sin (thetan)
##
	a3[1,1] =  cosx
	a3[1,2] =  cost*sinx
	a3[1,3] =  sinx*sint
	a3[2,1] = -sinx
	a3[2,2] =  cost*cosx
	a3[2,3] =  cosx*sint
	a3[3,1] =  0.
	a3[3,2] = -sint
	a3[3,3] =  cost

	rhon = DEGTORAD(roll3)
	cosr = cos (rhon)
	sinr = sin (rhon)

# ... below assumes phin=0.
	a3[1,1] =  cosx*cosr
	a3[1,2] =  sint*sinr + cost*sinx*cosr
	a3[1,3] = -cost*sinr + sint*sinx*cosr
	a3[2,1] = -sinx
	a3[2,2] =  cost*cosx
	a3[2,3] =  cosx*sint
	a3[3,1] =  cost*sinr
	a3[3,2] = -sint*cosr + cost*sinx*sinr
	a3[3,3] =  cost*cosr + sint*sinx*sinr

# CAMERA
# again, tranformation from theta-x,y is better, although this is not ridiculous
	thetan = DEGTORAD(2.33)
	phin = DEGTORAD(90.) + HALFPI
		phin = phin + PI
		thetan = -thetan
	cosp = cos (phin)
	sinp = sin (phin)
	cost = cos (thetan)
	sint = sin (thetan)

	a4[1,1] = cosp
	a4[1,2] = sinp
	a4[1,3] = 0.
	a4[2,1] = -cost*sinp
	a4[2,2] = cost*cosp
	a4[2,3] = sint
	a4[3,1] = sint*sinp
	a4[3,2] = -sint*cosp
	a4[3,3] = cost

# CCD: define the geometry of the mosaic
	call ccd_geom (ccd, 0., 0., 0.)		# TMP HARDCODE


# Ready to loop through:
	pa = 0.

	while (fscan (fda) != EOF) {

		call gargd (x)
		call gargd (y)
		call gargd (w)

		if (nscan() < 2)
			next

		call mask_to_proj (x, y, pa, x, y, pa)

# comment out above call; add:
# call eprintf ("SPECIAL FOR ZEMAX!!\n")
# w=0.5000

# convert to r[3]:
		rp = sqrt (x*x + y*y)
		hm = R_CURV - sqrt (R_CURV*R_CURV - rp*rp)
		theta = atan (rp / (D_1-hm))
		phi = atan2 (y, x)

		cosp = cos (phi)
		sinp = sin (phi)
		cost = cos (theta)
		sint = sin (theta)

		r[1] = cosp * sint
		r[2] = sinp * sint
		r[3] = cost

# COLLIMATOR:
		call coll_angle (x, y, theta, phi)

		thetan = theta
		phin = phi + HALFPI
		cosp = cos (phin)
		sinp = sin (phin)
		cost = cos (thetan)
		sint = sin (thetan)

		a1[1,1] = cosp
		a1[1,2] = sinp
		a1[1,3] = 0.
		a1[2,1] = -cost*sinp
		a1[2,2] = cost*cosp
		a1[2,3] = sint
		a1[3,1] = sint*sinp
		a1[3,2] = -sint*cosp
		a1[3,3] = cost

		call refl (r, a1)
		call gen_xfm (r, e1, YES)
		call refl (r, a2)
## NB COMMENT LINE BELOW for ZEMAX
		call gen_xfm (r, a3, YES)

		tx = atan2 (-r[1], -r[3])
		ty = atan2 (-r[2], -r[3])

## HERE IS THE GRATING EQUATION:
## m*wave = -n * space * cos(gamma) * ( sin(beta) + sin(alpha) )
		alpha = -ty
		gamma = -tx   # both alpha, gamma seem reversed; but gamma must be *-1
		gamma = atan2 (r[1], sqrt (r[3]*r[3]+r[2]*r[2]))

## add the following for ZEMAX compare and comment out remainder of loop
# call printf ("%8.5f %8.5f %8.3f \n")
# call pargd (r[1]/r[3])
# call pargd (r[2]/r[3])
# call pargd (hm)

		beta = asin ((ord * w / space / cos (gamma)) - sin (alpha))

		call grat_to_ics (beta, gamma, foclen, a4, a3, xpix, ypix)

		n = ident_ccd (xpix, ypix)
		call ics_to_ccd (xpix, ypix, ccd, n, xpix, ypix)

# Convert to full mosaic image (TMP!!):
		if (n > 4) {
			my = 2
			mx = n - 4
		} else {
			my = 1
			mx = n
		}

		xpix = xpix + ((mx-1)*2048 + 48)
		ypix = ypix + (my-1)*4096

		call printf ("%8.2f %8.2f  #  %7.1f \n")
			call pargr (xpix)
			call pargr (ypix)
			call pargd (w*10000.)
	}
end

