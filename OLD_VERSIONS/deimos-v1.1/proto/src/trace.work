# TRACE: Trace mask points through DEIMOS
# NOTES: redefined p3 & GRATING XFM currently redefined for pure roll, but
# eventually probably want to return to old system as phi3 is probably a
# constant to be solved for

# TBD: there are 3 definitions for grating xfm in setup -- trim [commented out]
# TBD: implement errors in appropriate places
# TBD: resolve CCD description (done?)
# TBD: resolve p3/roll3 grating issue (see below)
# TBD: resolve error in xfmx: DONE, but more compact way to pass xfms desired ..
# TBD: put in "off chip" flag (done)
# TBD: possibly add coll_distance to sys
# TBD: review coll_error implementation in pt_xfm() [first order only]
# TBD: review and implement the grating xfms as sys params

# TBD: clean up input parameters

include	<math.h>
include	"instrument.h"

# define	D_1	20023.15D0
# define	R_CURV	2071.88D0
define	D_1	20018.4D0	# see deimos.h PPLDIST
define	R_CURV	2124.71D0	# ditto; r=83.65in in this case = R_IMSURF


procedure	t_trace()

char	input[SZ_FNAME]			# input file name (x,y,w)
double	t1, p1
double	t2, p2
double	t3, p3, o3
double	roll3
pointer	fda

double	e1[3,3], a2[3,3], a3[3,3], a4[3,3]	# transforms
real	ccd[NCCD,3]	
double	sys[NPARAM]		# system parameters

int	i	# TMP?

int	clgeti()
real	clgetr()
pointer	open()

begin
	t1 = clgetr ("coll_angle")
	p1 = clgetr ("coll_phi")
	t2 = clgetr ("t2")
	p2 = clgetr ("p2")
	t3 = clgetr ("mu")
	p3 = clgetr ("p3")		# z-misalignment of tilt angle
	o3 = clgetr ("o3")		# independent yaw
	roll3 = clgetr ("roll3")	# roll, assuming p3=0

	CAM_FOC(sys) = clgetr ("cam_foc")
	ORDER(sys) = clgeti ("norder")
	GRLINES(sys) = clgeti ("gmm")
	X_OPT(sys) = clgetr ("x_optaxis")
	Y_OPT(sys) = clgetr ("y_optaxis")
	MOS_ROT(sys) = DEGTORAD(clgetr ("mos_rotation"))
# TMP HARDCODES:

COL_ERR(sys) = DEGTORAD(2.*t1)
COL_PHI(sys) = DEGTORAD(p1)

TNT_ANG(sys) = DEGTORAD(71.5 + t2)
TNT_PHI(sys) = DEGTORAD(90. + p2)

MU(sys) = DEGTORAD (t3)
GR_YERR(sys) = DEGTORAD (roll3)
GR_ZERR(sys) = DEGTORAD (o3)
CAM_ANG(sys) = DEGTORAD (2.33)
CAM_PHI(sys) = DEGTORAD (90.)

do i = 1, 8 {
	CN_XERR(sys,i) = 0.
	CN_YERR(sys,i) = 0.
	CN_RERR(sys,i) = 0.
}



	call clgstr ("input", input, SZ_FNAME)
        fda = open (input, READ_ONLY, TEXT_FILE)

	call printf ("# ord=%2f  lines=%5f  tilt=%-6.2f  phi=%-8.4f  roll=%-7.4f yaw=%-7.4f\n")
		call pargd (ORDER(sys))
		call pargd (GRLINES(sys))
		call pargd (t3)
		call pargd (p3)
		call pargd (roll3)
		call pargd (o3)
	call printf ("#  t1=%6.4f p1=%8.4f   t2=%7.4f p2=%8.4f \n")
		call pargd (t1)
		call pargd (p1)
		call pargd (t2)
		call pargd (p2)


	call setup (e1, a2, a3, a4, ccd, sys)

	call full_trace (fda, e1, a2, a3, a4, ccd, sys)

	call close (fda)

end

procedure	setup (e1, a2, a3, a4, ccd, sys)

# double	t1, p1		# theta, phi of normal 1
# double	t2, p2		# theta, phi of normal 2
# double	p3, o3	# theta, phi of normal 3
# double	roll3

double	a2[3,3], a3[3,3], a4[3,3]	# transforms
double	e1[3,3]
real	ccd[NCCD,3]	
double	sys[NPARAM]		# system parameters


double	phin, thetan
double	cost, sint, cosp, sinp
double	xsi, cosx, sinx
double	rhon
double	cosr, sinr

begin

# COLL ERROR (first order):
# In this case, we must remove the phi we put in, hence the more complex form
	thetan = COL_ERR(sys)
	phin = COL_PHI(sys) + HALFPI
	cosp = cos (phin)
	sinp = sin (phin)
	cost = cos (thetan)
	sint = sin (thetan)

	e1[1,1] =  1 - (1-cost)*sinp*sinp	# cosp*cosp + cost*sinp*sinp
	e1[1,2] =  (1-cost) * cosp*sinp
	e1[1,3] = -sinp*sint
	e1[2,1] =  (1-cost) * cosp*sinp
	e1[2,2] =  1 - (1-cost)*cosp*cosp	# sinp*sinp + cost*cosp*cosp
	e1[2,3] =  cosp*sint
	e1[3,1] =  sint*sinp
	e1[3,2] = -sint*cosp
	e1[3,3] =  cost


# TENT MIRROR:
# this mirror is OK to leave in del-theta,phi
	thetan = TNT_ANG(sys)
	phin = TNT_PHI(sys) + HALFPI
	cosp = cos (phin)
	sinp = sin (phin)
	cost = cos (thetan)
	sint = sin (thetan)

	a2[1,1] = cosp
	a2[1,2] = sinp
	a2[1,3] = 0.
	a2[2,1] = -cost*sinp
	a2[2,2] = cost*cosp
	a2[2,3] = sint
	a2[3,1] = sint*sinp
	a2[3,2] = -sint*cosp
	a2[3,3] = cost

# MIRROR/GRATING:
# Better in thetax, thetay description (see above)
# for GRATING: need to add the third rotation
# Note the hack with phin + PI.  This is needed to keep the transformed
# x, y axes from flipping, wrt the original x,y.  Not a problem wrt reflections
# but if we want to work _within_ a system it is a problem. Cf. camera also
# note that this _forces_ us to work in a particular hemisphere, and thus we
# must make use of the negative theta as needed.

	thetan = MU(sys)

#	phin = DEGTORAD(p3) + HALFPI
#	if (p3 > 0.) {
#		phin = phin + PI
#		thetan = -thetan
#	}
#
#	cosp = cos (phin)
#	sinp = sin (phin)
#	cost = cos (thetan)
#	sint = sin (thetan)
#	cosx = cos (xsi)
#	sinx = sin (xsi)
#
#	a3[1,1] =  cosx*cosp - cost*sinp*sinx	#  cosp
#	a3[1,2] =  cosx*sinp + cost*cosp*sinx	#  sinp
#	a3[1,3] =  sinx*sint			#  0.
#	a3[2,1] = -sinx*cosp - cost*sinp*cosx	# -cost*sinp
#	a3[2,2] = -sinx*sinp + cost*cosp*cosx	#  cost*cosp
#	a3[2,3] =  cosx*sint			#  sint
#	a3[3,1] =  sint*sinp
#	a3[3,2] = -sint*cosp
#	a3[3,3] =  cost
#
#
#	thetan = -DEGTORAD(t3)
#	thetan = -MU(sys)
#	phin = 0.

#	cosp = 1.
#	sinp = 0.
#	cost = cos (thetan)
#	sint = sin (thetan)
##
#	a3[1,1] =  cosx
#	a3[1,2] =  cost*sinx
#	a3[1,3] =  sinx*sint
#	a3[2,1] = -sinx
#	a3[2,2] =  cost*cosx
#	a3[2,3] =  cosx*sint
#	a3[3,1] =  0.
#	a3[3,2] = -sint
#	a3[3,3] =  cost
#

	thetan = -MU(sys)
	xsi = GR_ZERR(sys)
	rhon = GR_YERR(sys)
	cost = cos (thetan)
	sint = sin (thetan)
	cosx = cos (xsi)
	sinx = sin (xsi)
	cosr = cos (rhon)
	sinr = sin (rhon)

# ... below assumes phin=0. (ie adopts the roll/yaw approach)
	a3[1,1] =  cosx*cosr
	a3[1,2] =  sint*sinr + cost*sinx*cosr
	a3[1,3] = -cost*sinr + sint*sinx*cosr
	a3[2,1] = -sinx
	a3[2,2] =  cost*cosx
	a3[2,3] =  cosx*sint
	a3[3,1] =  cost*sinr
	a3[3,2] = -sint*cosr + cost*sinx*sinr
	a3[3,3] =  cost*cosr + sint*sinx*sinr

# CAMERA
# again, tranformation from theta-x,y is better, although this is not ridiculous
	thetan = CAM_ANG(sys)
	phin = CAM_PHI(sys) + HALFPI
		phin = phin + PI
		thetan = -thetan
	cosp = cos (phin)
	sinp = sin (phin)
	cost = cos (thetan)
	sint = sin (thetan)

	a4[1,1] = cosp
	a4[1,2] = sinp
	a4[1,3] = 0.
	a4[2,1] = -cost*sinp
	a4[2,2] = cost*cosp
	a4[2,3] = sint
	a4[3,1] = sint*sinp
	a4[3,2] = -sint*cosp
	a4[3,3] = cost

# CCD: define the geometry of the mosaic
	call ccd_geom (ccd, sys)

end


# CCDGEOM: specify the geometry of the CCDs in the mosaic
# Probably want to add FCS devices also (note that FDS CCDs are rotated 90deg)
# Order is x(pix), y(pix), theta(deg)

procedure ccd_geom (a, sys)

real	a[NCCD,3]
double	sys[NPARAM]		# system params

int	i

begin
#	coeff    pix-off   nom.gap    adjustment

	a[1,1] = -4096.  - 100.		- 46.41
	a[1,2] = -4096.  -   3.3333	+  7.16
	a[1,3] = 0.			+  DEGTORAD(0.2284)

	a[2,1] = -2048.  -  33.3333     - 25.09
	a[2,2] = -4096.  -   3.3333	-  7.49
	a[2,3] = 0.			+  DEGTORAD(0.1239)

	a[3,1] = 0.      +  33.3333
	a[3,2] = -4096.  -   3.3333
	a[3,3] = 0.

	a[4,1] = 2048.   + 100.		+ 29.81
	a[4,2] = -4096.  -   3.3333	+  1.32
	a[4,3] = 0.			- DEGTORAD(0.1655)

	a[5,1] = -4096.  - 100.		- 46.30
	a[5,2] = 0.      +   3.3333	+ 46.22
	a[5,3] = 0.			+ DEGTORAD(0.1275)

	a[6,1] = -2048.  -  33.3333	-  2.32
	a[6,2] = 0.      +   3.3333	+ 23.20
	a[6,3] = 0.			+ DEGTORAD(0.2261)

	a[7,1] = 0.      +  33.3333	+  2.54
	a[7,2] = 0.      +   3.3333	+ 33.85
	a[7,3] = 0.			+ DEGTORAD(0.0159)

	a[8,1] = 2048.   + 100.		+ 35.19
	a[8,2] = 0.      +   3.3333	+ 43.21
	a[8,3] = 0.			- DEGTORAD(0.0322)

# CN_XOFF(sys,1) = a[1,1]
# CN_YOFF(sys,1) = a[1,2]
# CN_ROT(sys,1)  = a[1,3]

	do i = 1, NCCD {
		a[i,1] = a[i,1] - X_OPT(sys)   + CN_XERR(sys,i)
		a[i,2] = a[i,2] - Y_OPT(sys)   + CN_YERR(sys,i)
		a[i,3] = a[i,3] - MOS_ROT(sys) + CN_RERR(sys,i)
	}
end


# FULL_TRACE: trace chief rays through system.  The collimator transform must
# be worked out for each ray, so only the collimator error appears as input.
# There will be a simpler version put forth that uses a polynomial mapping
# of input alphas calculated once the errors are established.

procedure	full_trace (fda, e1, a2, a3, a4, ccd, sys)

pointer	fda				# file descriptor for input file
double	e1[3,3]				# collimator error transform
double	a2[3,3], a3[3,3], a4[3,3]	# transforms
real	ccd[NCCD,3]	
double	sys[NPARAM]			# system parameters

real	xpix, ypix

int	n				# CCD number

double	x, y, w

int	stat

int	mosim_coord()
int	fscan(), nscan()

begin

# Ready to loop through:
	while (fscan (fda) != EOF) {

		call gargd (x)
		call gargd (y)
		call gargd (w)

		if (nscan() < 2)
			next

		call pt_xfm (x, y, w, e1, a2, a3, a4, ccd, sys, xpix, ypix, n)

# Convert to full mosaic image
		stat = mosim_coord (xpix, ypix, n)

		call printf ("%8.2f %8.2f  #  %7.1f \n")
			call pargr (xpix)
			call pargr (ypix)
			call pargd (w*10000.)
	}
end


procedure	pt_xfm (xmm, ymm, wave, e1, a2, a3, a4, ccd, sys, xpix, ypix, n)

double	xmm, ymm, wave
double	e1[3,3], a2[3,3], a3[3,3], a4[3,3]	# transforms
real	ccd[NCCD,3]	
double	sys[NPARAM]				# system parameters
real	xpix, ypix
int	n

double	a1[3,3]

double	x, y, pa
double	phi, theta
double	phin, thetan
double	cost, sint, cosp, sinp

double	r[3]

double	alpha, beta, gamma
double	rp, hm
double	tx, ty	# TMP!
double	space

int	ident_ccd()
begin
	pa = 0.
	x = xmm
	y = ymm
	call mask_to_proj (x, y, pa, x, y, pa)

# comment out above call; add:
# call eprintf ("SPECIAL FOR ZEMAX!!\n")
# refwave=0.5000

# convert to r[3]:
	rp = sqrt (x*x + y*y)
	hm = R_CURV - sqrt (R_CURV*R_CURV - rp*rp)
	theta = atan (rp / (D_1-hm))
	phi = atan2 (y, x)

	cosp = cos (phi)
	sinp = sin (phi)
	cost = cos (theta)
	sint = sin (theta)

	r[1] = cosp * sint
	r[2] = sinp * sint
	r[3] = cost

# call eprintf ("\n[R]: %6f %6f %6f  ")
# call pargd (r[1])
# call pargd (r[2])
# call pargd (r[3])

# COLLIMATOR:
	call coll_angle (x, y, theta, phi)

	thetan = theta
	phin = phi + HALFPI
	cosp = cos (phin)
	sinp = sin (phin)
	cost = cos (thetan)
	sint = sin (thetan)

	a1[1,1] = cosp
	a1[1,2] = sinp
	a1[1,3] = 0.
	a1[2,1] = -cost*sinp
	a1[2,2] = cost*cosp
	a1[2,3] = sint
	a1[3,1] = sint*sinp
	a1[3,2] = -sint*cosp
	a1[3,3] = cost

	call refl (r, a1)
# REVIEW implementation below
	call gen_xfm (r, e1, YES)
	call refl (r, a2)
## NB COMMENT LINE BELOW for ZEMAX cmp
	call gen_xfm (r, a3, YES)

	tx = atan2 (-r[1], -r[3])
	ty = atan2 (-r[2], -r[3])

## HERE IS THE GRATING EQUATION:
## m*wave = -n * space * cos(gamma) * ( sin(beta) + sin(alpha) )

	alpha = -ty
	gamma = atan2 (r[1], sqrt (r[3]*r[3]+r[2]*r[2]))

## add the following for ZEMAX compare and comment out remainder of loop
# call printf ("%8.5f %8.5f %8.3f \n")
# call pargd (r[1]/r[3])
# call pargd (r[2]/r[3])
# call pargd (hm)

	space = 1000. / GRLINES(sys)
	beta = asin ((ORDER(sys) * wave / space / cos (gamma)) - sin (alpha))

	call grat_to_ics (beta, gamma, CAM_FOC(sys), a4, a3, xpix, ypix)
	n = ident_ccd (xpix, ypix)
	call ics_to_ccd (xpix, ypix, ccd, n, xpix, ypix)
end


# MOSIM_COORD: convert chip coord --> standard mosaic image coordinates
# TMP! TMP!  hardcoded values ...

int	procedure mosim_coord (xpix, ypix, n)

real	xpix, ypix
int	n

int	mx, my
real	flagx, flagy

begin
	if (n > 4) {
		my = 2
		mx = n - 4
	} else {
		my = 1
		mx = n
	}

# flag if off chip:
	if (xpix < 1. || xpix > 2048.)
		flagx = -1.
	else
		flagx = 1.

	if (ypix < 1. || ypix > 4096.)
		flagy = -1.
	else
		flagy = 1.

	xpix = xpix + ((mx-1)*2048 + 48)
	ypix = ypix + (my-1)*4096

	xpix = xpix * flagx
	ypix = ypix * flagy

	if (flagx > 0. && flagy > 0.)
		return (ON_CHIP)
	else
		return (OFF_CHIP)
end


################### FROM NEWLRIS: ################################

define		X_HWID	1.5		# x half-width of triangle function
define		Y_HWID	1.5		# y half-width of triangle function
define		X_CRAD	13		# x centering radius
define		Y_CRAD	13		# y centering radius


procedure	bx_recenter (im, xs, ys, nslit, xsz, ysz)

pointer	im
real	xs[nslit], ys[nslit]		# x,y vectors of slit/boxes
int	nslit
real	xsz, ysz			# Full size of boxes (pix)

int	nxbox, nybox			# Size of subraster

int	ncols, nlines
int	i, j, k

int	nx, ny
real	xb, yb
int 	x1, y1, x2, y2
pointer	bufx, bufy, bufzx, bufzy
pointer	buf

int	clgeti()
pointer	imgs2r()

begin
	nxbox = clgeti ("nxbox")
	nybox = clgeti ("nybox")

	ncols = IM_LEN(im,1)
	nlines = IM_LEN(im,2)

# Allocate arrays for marginal plots
	    call malloc (bufx, nxbox, TY_REAL)
	    call malloc (bufy, nybox, TY_REAL)
	    call malloc (bufzx, nxbox, TY_REAL)
	    call malloc (bufzy, nybox, TY_REAL)

# Find the Box; we do a kludge -- run this twice, recentered on box the 2nd time
# probably not necessary
	do k = 1, nslit {
		xb = xs[k]
		yb = ys[k]
		if (xb < 1.+xsz || xb > ncols-xsz ||
					yb < 1.+ysz || yb > nlines-ysz) {
			xs[k] = INDEF
			ys[k] = INDEF
			next
		}

		do j = 1, 2 {
		    x1 = xb - nxbox/2
		    x2 = x1 + nxbox - 1
		    y1 = yb - nybox/2
		    y2 = y1 + nybox - 1

# checks on out-of-bounds
		    x1 = max (1, x1)
		    x2 = min (ncols, x2)
		    y1 = max (1, y1)
		    y2 = min (nlines, y2)

# Actual box length 
		    nx = x2 - x1 + 1
		    ny = y2 - y1 + 1

# Get the image section
		    buf = imgs2r (im, x1, x2, y1, y2)

# Fill position vectors
		    do i = 0, nx-1 {
			Memr[bufx+i] = i + x1
		    }
		    do i = 0, ny-1 {
			Memr[bufy+i] = i + y1
		    }

# Get the box position
		    call box_center (Memr[bufx], Memr[bufy], Memr[buf], nx, ny,
			Memr[bufzx], Memr[bufzy], xsz, ysz, xb, yb)

		    if (xb == INDEF || yb == INDEF)
			break
		}

		call printf ("Box center:  %6.2f %6.2f  (del:%4.1f,%4.1f)\n")
			call pargr (xb)
			call pargr (yb)
			if (xb != INDEF && yb != INDEF) {
				call pargr (xb-xs[k])
				call pargr (yb-ys[k])
			} else {
				call pargr (INDEF)
				call pargr (INDEF)
			}

		xs[k] = xb		# replace with new coord.
		ys[k] = yb		# replace with new coord.
	}

# Done with the box-finding: clean up
	call mfree (bufzy, TY_REAL)
	call mfree (bufzx, TY_REAL)
	call mfree (bufy, TY_REAL)
	call mfree (bufx, TY_REAL)
end

procedure	box_center (x, y, z, nx, ny, zx, zy, xsz, ysz, cx, cy)

real	x[nx], y[ny]		# position vectors
real	z[nx,ny]		# intensity array
int	nx, ny			# size of vectors/array
real	zx[nx], zy[ny]		# Work vectors for x,y cuts
real	xsz, ysz		# pixel sizes of boxes
real	cx, cy			# returned centers
real	grad			# new gradient, currently unused

int	i, j, i1, i2, j1, j2

real	saw_xcorr()
begin

# Get the initial profile
	call amovkr (0., zx, nx)
	call amovkr (0., zy, ny)
	j1 = 0.5 * ny - 1
	j2 = j1 + 4
	do j = j1, j2 {
		call aaddr (zx, z[1,j], zx, nx)
	}
	i1 = 0.5 * nx - 1
	i2 = i1 + 4
	do j = 1, ny {
	    do i = i1, i2 {
		zy[j] = zy[j] + z[i,j]
	    }
	}
	call amulkr (zx, 1./real(j2-j1+1), zx, nx)
	call amulkr (zy, 1./real(i2-i1+1), zy, ny)

	cx = saw_xcorr (x, zx, nx, xsz, X_HWID, X_CRAD, grad)
	if (cx ==INDEF) {
		call eprintf ("Can't find box at %4.0f,%4.0f\n")
			call pargr (x[nx/2])
			call pargr (y[ny/2])
	}
	cy = saw_xcorr (y, zy, ny, ysz, Y_HWID, Y_CRAD, grad)
	if (cy ==INDEF) {
		call eprintf ("Can't find box at %4.0f,%4.0f -- check positions on image and prescan value!\n")
			call pargr (x[nx/2])
			call pargr (y[ny/2])
	}

	if (cx == INDEF || cy == INDEF)
		return

# Get the final profile:
	call amovkr (0., zx, nx)
	call amovkr (0., zy, ny)
	j1 = cy - y[1] + 1 - 0.5 * xsz + X_HWID
	j2 = cy - y[1] + 1 + 0.5 * xsz - X_HWID + 0.5
	do j = j1, j2 {
		call aaddr (zx, z[1,j], zx, nx)
	}
	i1 = cx - x[1] + 1 - 0.5 * xsz + X_HWID
	i2 = cx - x[1] + 1 + 0.5 * xsz - X_HWID + 0.5
	do j = 1, ny {
	    do i = i1, i2 {
		zy[j] = zy[j] + z[i,j]
	    }
	}
	call amulkr (zx, 1./real(j2-j1+1), zx, nx)
	call amulkr (zy, 1./real(i2-i1+1), zy, ny)

	cx = saw_xcorr (x, zx, nx, xsz, X_HWID, X_CRAD, grad)
	if (cx ==INDEF)
		call eprintf ("Got lost on recenter; check input positions")
	cy = saw_xcorr (y, zy, ny, ysz, Y_HWID, Y_CRAD, grad)
	if (cy ==INDEF)
		call eprintf ("Got lost on recenter; check input positions")

	if (cx == INDEF || cy == INDEF)
		return

# Print out centers for debugging
# call eprintf ("cx,cy final = %6.2f %6.2f\n")
# call pargr (cx)
# call pargr (cy)

end

############################### JUNK to work from ################

procedure x_trace ()

char	slits[SZ_FNAME]			# slit info file
char	output[SZ_FNAME]		# output extraction info
char	image[SZ_FNAME]			# optional image to measure
char	wavelist[SZ_FNAME]		# optional wavelength list
char	grating[SZ_GRNM]		# name of grating
real	refwave				# wavelength
int	index				# identifying index number
real	xsz, ysz			# size in mm of aperture

#
bool	measure				# measure image & write output file?
pointer	im				# image descriptor
pointer	fda, fdb			# file descriptor for in/output files
pointer	fdw				# file descriptor for wavelist

double	sys[NPARAM]			# extraction/position params

int	nslit				# No. slits
pointer	bufxmm				# pointer to slit x
pointer	bufymm				# pointer to slit y 
pointer	bufwav				# pointer to wavelengths
pointer	bufx, bufy			# pointers to x,y (pixel) slit values

char	tchar
int	i, j
int	nwave
int	nline

int	niter
real	xtarg

real	relscale				# relative scale of 2 vectors
real	anamx				# anamorphic factor in x
real	xmin, xmax
int	ncol
real	x1, x2, y1, y2

bool	streq(), clgetb(), strne()
int	access(), clgeti()
int	line_count()
int	fscan(), nscan()
real	clgetr()
pointer	open(), immap()

begin
# Read in parameters:
	xsz = clgetr ("xmm") / clgetr ("mm_pix")
	ysz = clgetr ("ymm") / clgetr ("mm_pix")

	index = clgeti ("index")

	call clgstr ("slits", slits, SZ_FNAME)
	fda = open (slits, READ_ONLY, TEXT_FILE)

	call clgstr ("wavelist", wavelist, SZ_FNAME)
#   first count the entries ...
	if (strne (wavelist, "")) {
		fdw = open (wavelist, READ_ONLY, TEXT_FILE)
		nwave = line_count (fdw)
		call malloc (bufwav, nwave, TY_DOUBLE)

		nwave = 0
		while (fscan (fdw) != EOF) {
			call gargwrd (tchar, 1)
			if (tchar == '#') {
				next
			}
			call reset_scan()
			call gargr (refwave)
			Memd[bufwav+nwave] = refwave / 1.e4	# to microns
			if (nscan() < 1)
				next
			nwave = nwave + 1
		}
		call close (fdw)
call eprintf ("Number of input wavelengths: %d\n")
call pargi (nwave)

	} else {
		refwave = clgetr ("refwave")
		nwave = 1
		call malloc (bufwav, nwave, TY_DOUBLE)
		Memd[bufwav] = refwave
	}

	

# Read in slit positions here
	nslit = line_count (fda)
	call malloc (bufxmm, nslit, TY_DOUBLE)
	call malloc (bufymm, nslit, TY_DOUBLE)
	nslit = 0
	while (fscan (fda) != EOF) {
		call gargwrd (tchar, 1)
		if (tchar == '#') {
			next
		}
		call reset_scan()
		call gargd (Memd[bufxmm+nslit])
		call gargd (Memd[bufymm+nslit])
		if (nscan() < 2)
			next
		nslit = nslit + 1
	}
	call close (fda)

# Allocate these vectors
	call malloc (bufx  , nslit, TY_REAL)	# x (pixels) of slit
	call malloc (bufy  , nslit, TY_REAL)	# y (pixels) of slit


# Now solve for image geometry:
	do i = 1, nslit {
		call pt_xfm (  )
#	call pt_geom (Memr[bufxmm], Memr[bufymm], Memr[bufzxo], Memr[bufzyo],
#		Memr[bufx], Memr[bufy], nslit, fdz, cd, sys, refwave, xfm)
	}


	if (ORDER(sys) != 0) {
		lambda = 1.e7 / GRLINES(sys) * ORDER(sys) *
			(sin (alpha) - sin (beta))
		relscale = 1.e7 / GRLINES(sys) * ORDER(sys) *
				(cos (alpha) + cos (beta))
		relscale = RADTODEG (1. / relscale)
	} else {
		lambda = INDEF
		relscale = INDEF
	}
		

call eprintf ("\nOn-axis values: beta =%8.4f ==> lambda =%8.2f\n")
call pargr (RADTODEG(beta))
call pargr (lambda)
call eprintf ("Correct at %8.5f degree / A\n")
call pargr (relscale)

	anamx = cos (alpha) / cos (beta)
	call eprintf ("box size:  %4.1f x %4.1f (px)\n")
		call pargr (xsz*anamx)
		call pargr (ysz)

# Measure the centers on an image, if image name given
	call clgstr ("image", image, SZ_FNAME)
	measure = strne (image, "")
	if (!measure) {
		call printf ("No Image for Measured Centers\n")
		do i = 0, nslit-1 {
		    call printf ("%03d  %7.3f %7.3f  %7.2f    %7.2f %7.2f \n")
		    	call pargi (index)
		    	call pargd (Memd[bufxmm+i])
		    	call pargd (Memd[bufymm+i])
		    	call pargr (refwave)
		    	call pargr (Memr[bufx+i])
		    	call pargr (Memr[bufy+i])
		}

		niter = clgeti ("niter")
		xtarg = clgetr ("xtarget")
		call xiter_mu (Memd[bufxmm], Memd[bufymm], refwave, xtarg,
							niter, sys)
	} else {

# Open output file, count entries as needed
	    call clgstr ("output", output, SZ_FNAME)
	    if (measure && access (output, 0, 0,) == YES) {
#   first count the entries ...
		fdb = open (output, READ_ONLY, TEXT_FILE)
		nline = 0
		while (fscan (fdb) != EOF) {
			call gargwrd (tchar, 1)
			call reset_scan()
			if (tchar == '#') {
				next
			}
			nline = nline + 1
		}
		call close (fdb)
#  ... then reopen
		call eprintf ("appending to %s \n")
			call pargstr (output, SZ_FNAME)
		fdb = open (output, APPEND, TEXT_FILE)
	    } else if (measure) {
		fdb = open (output, NEW_FILE, TEXT_FILE)
		nline = 0
	    }


# Open image:
		im = immap (image, READ_ONLY, 0)
		ncol = IM_LEN (im,1)

# Loop and print as needed
		do j = 0, nwave-1 {
# solve for image geometry at new wavelenth:
		    refwave = Memd[bufwav+j]

call eprintf ("processing %d:  %7.2f \n")
call pargi (j)
call pargr (refwave)
		    call pt_geom (xmin, 167.8, Memr[bufzxo], Memr[bufzyo],
			x1, y1, 1, fdz, cd, sys, refwave, xfm)
		    call pt_geom (xmin, 167.8, Memr[bufzxo], Memr[bufzyo],
			x2, y2, 1, fdz, cd, sys, refwave, xfm)
## TMP - FIX here
		    if (max (x1, x2) < 1. || min (x1, x2) >= ncol) {
				call eprintf ("Line off detector\n")
				next
		    }

		    call pt_geom (Memr[bufxmm], Memr[bufymm], Memr[bufzxo],
			Memr[bufzyo], Memr[bufx], Memr[bufy], nslit, fdz, cd,
			sys, refwave, xfm)

		    call bx_recenter (im, Memr[bufx], Memr[bufy], nslit, xsz*anamx, ysz)
# write measured positions to output file
#	call fprintf (fdb, "# xmm ymm   xpix ypix    ID\n")
		    do i = 0, nslit-1 {
			call fprintf (fdb, "%03d  %7.3f %7.3f  %7.2f    %7.2f %7.2f \n")
				call pargi (index)
				call pargd (Memd[bufxmm+i])
				call pargd (Memd[bufymm+i])
				call pargr (refwave)
				call pargr (Memr[bufx+i])
				call pargr (Memr[bufy+i])
		    }
		    nline = nline + nslit
		}

# Write the setup info:
	call fprintf (fdb, "# %03d %s %7.3f  %6.3f %6.3f  %5.0f %3.0f %4d\n")
		call pargi (index)
		call pargstr (image)
		call pargr (MU(sys))
		call pargd (GR_YERR(sys))
		call pargd (GR_ZERR(sys))
		call pargd (GRLINES(sys))
		call pargd (ORDER(sys))
		call pargi (nline)


# Close up
		call imunmap (im)
		call close (fdb)
	}


# Release memory
	call mfree (bufy, TY_REAL)
	call mfree (bufy, TY_REAL)
	call mfree (bufymm, TY_DOUBLE)
	call mfree (bufxmm, TY_DOUBLE)
	call mfree (bufwav, TY_DOUBLE)
end


