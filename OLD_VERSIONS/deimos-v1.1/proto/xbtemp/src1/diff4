14d13
< real	scaling				# scaling difference from 1
16d14
< 
18d15
< pointer	map[4]				# pointers to surf fits (1,2=amap;3,4=b)
20,21c17,18
< double	sys[NPARAM]			# system parameters
< real	ccd[NCCD,3]			# CCD geometry
---
> double	sys[NPARAM]				# system parameters
> real	ccd[NCCD,3]				# CCD geometry
22a20,22
> double	r[3]
> double	alpha, beta, gamma
> real	tanx, tany			# should be double; check mapping evals
25,27c25,26
< int	stat
< int	chip
< 
---
> real	cost, sint
> int	n, stat
29a29,31
> pointer	asfx, asfy			# pointers to surface fits (amap)
> pointer	bsfx, bsfy			# pointers to surface fits (bmap)
> 
32,34c34
< int	qxfm(), qxfm_init()
< 
< bool	strne()
---
> int	mosim_coord(), ident_ccd()
36d35
< int	fscan(), nscan()
37a37
> real	gseval()
38a39,40
> bool	strne()
> int	fscan(), nscan()
53d54
< 	scaling = 1. + clgetr ("scale_adj")
68,69c69,71
< # Initialize the mappings
< 	stat = qxfm_init (fda, fdb, map, a3, sys, ccd)
---
> # Iitialize the maps
> 	call gs_ingest (fda, asfx, asfy)
> 	call gs_ingest (fdb, bsfx, bsfy)
70a73,82
> #######################################################################
> # Below is the actual calculation; gseval simply evaluates the mappings
> #######################################################################
> 
> # set up the grating transform
> 	call gsetup (a3, sys)
> 
> # CCD: define the geometry of the mosaic
> 	call ccd_geom (ccd, sys)
> 
79,142d90
< # calculate the mapping
< 	stat = qxfm (map, a3, sys, ccd, xmm, ymm, wave, scaling, xics, yics, xpix, ypix, chip)
< 
< 	if (stat == OFF_CHIP) {
< call eprintf ("%8.3f %7.3f %8.2f -->ICS: %7.1f %7.1f -->OFF CHIPS \n")
< 		call pargr (xmm)
< 		call pargr (ymm)
< 		call pargr (wave*1.e4)
< 		call pargr (xics)
< 		call pargr (yics)
< call printf ("%s OFF_CHIP\n")
< call pargstr (id)		# TMP
< 	} else {
< call eprintf ("%8.3f %7.3f %8.2f -->ICS: %7.1f %7.1f --> %6.1f %6.1f (%d)\n")
< 		call pargr (xmm)
< 		call pargr (ymm)
< 		call pargr (wave*1.e4)
< 		call pargr (xics)
< 		call pargr (yics)
< 		call pargr (xpix)
< 		call pargr (ypix)
< 		call pargi (chip)
< call printf ("%6.1f %6.1f %-16s\n")
< call pargr (xpix)
< call pargr (ypix)
< call pargstr (id)		# TMP
< 	}
< 	}
< 
< 	if (file_list)
< 		call close (fd)
< 
< end
< 
< 
< 
< 
< int	procedure qxfm (map, a3, sys, ccd, xmm, ymm, wave, scaling, xics, yics, xpix, ypix, chip)
< 
< pointer	fda, fdb		# pointers to map input files
< 
< pointer	map[4]			# pointer to maps
< double	a3[3,3]			# grating transform
< double	sys[NPARAM]		# system parameters
< real	ccd[NCCD,3]		# CCD geometry
< real	xmm, ymm		# x,y slitmask coords
< real	wave			# wavelength (um)
< real	scaling			# scaling adjustment
< real	xics, yics		# pixel values in ICS
< real	xpix, ypix		# pixel values on CCD (PANE coordinates)
< int	chip			# CCD number
< int	stat			# on/off chip status
< 
< double	r[3]
< double	alpha, beta, gamma
< real	tanx, tany		# should be double; check mapping evals
< int	n
< 
< int	mosim_coord(), ident_ccd()
< real	gseval()
< 
< int	qxfm_init()
< begin
< 
144,148c92,96
< 	tanx = gseval (map[1], xmm, ymm)
< 	tany = gseval (map[2], xmm, ymm)
< # call eprintf ("tanx,y: %5f %5f\n")
< # call pargr (tanx)
< # call pargr (tany)
---
> 	tanx = gseval (asfx, xmm, ymm)
> 	tany = gseval (asfy, xmm, ymm)
> call eprintf ("tanx,y: %5f %5f\n")
> call pargr (tanx)
> call pargr (tany)
161,162c109,110
< # Apply the grating equation
< 	beta = asin ((ORDER(sys)*GRLINES(sys)*abs(wave) / cos (gamma)) - sin (alpha))
---
> # Aplly the grating equation
> 	beta = asin ((ORDER(sys)*GRLINES(sys)*wave / cos (gamma)) - sin (alpha))
163a112,116
> call eprintf ("alpha,beta: %6f %6f %6f\n")
> call pargd (RADTODEG(alpha))
> call pargd (RADTODEG(beta))
> call pargd (RADTODEG(gamma))
> 
165,173c118,120
< 	if (wave > 0) {
< 		r[1] = sin (gamma)
< 		r[2] = sin (-beta) * cos (gamma)
< 		r[3] = cos (-beta) * cos (gamma)
< 	} else {
< 		r[1] = sin (gamma)
< 		r[2] = sin (beta) * cos (gamma)
< 		r[3] = cos (beta) * cos (gamma)
< 	}
---
> 	r[1] = sin (gamma)
> 	r[2] = sin (-beta) * cos (gamma)
> 	r[3] = cos (-beta) * cos (gamma)
183,184c130,131
< 	xics = gseval (map[3], tanx, tany)
< 	yics = gseval (map[4], tanx, tany)
---
> 	xics = gseval (bsfx, tanx, tany)
> 	yics = gseval (bsfy, tanx, tany)
186,187c133,142
< 	xics = xics * scaling
< 	yics = yics * scaling
---
> # get mapping into CCD pixels
> #	cost = cos (DEGTORAD(90.-0.27))
> #	sint = sin (DEGTORAD(90.-0.27))
> # the offset should be: 
> #	2. * CCDXPIX + 4.*CCDXEDG/PIX_SZ + 1.5*NOMXGAP/PIX_SZ +
> #		FCSYEDG/PIX_SZ * 0.5*FCSYPIX + gap = 4546.4 + gap
> ##	xics = xics - 4584.		# (relative to center of FCS2)
> ##	yics = yics - -600. 		# (relative to center of FCS2)
> #	xpix =  xics * cost - yics * sint + 600.
> #	ypix = -xics * sint - yics * cost + 300.
188a144,147
> # FUDGE  For some reason, ICS seems too large!
> call eprintf ("ICS fudge factor applied!!\n")
> 	xics = xics*0.997
> 
194d152
< 	chip = n
197d154
< 	return (stat)
198a156,180
> 	if (stat == OFF_CHIP) {
> call eprintf ("%8.3f %7.3f %8.2f -->ICS: %7.1f %7.1f -->OFF CHIPS \n")
> 		call pargr (xmm)
> 		call pargr (ymm)
> 		call pargr (wave*1.e4)
> 		call pargr (xics)
> 		call pargr (yics)
> call printf ("%s OFF_CHIP\n")
> call pargstr (id)		# TMP
> 	} else {
> call eprintf ("%8.3f %7.3f %8.2f -->ICS: %7.1f %7.1f --> %6.1f %6.1f (%d)\n")
> 		call pargr (xmm)
> 		call pargr (ymm)
> 		call pargr (wave*1.e4)
> 		call pargr (xics)
> 		call pargr (yics)
> 		call pargr (xpix)
> 		call pargr (ypix)
> 		call pargi (n)
> call printf ("%6.1f %6.1f %-16s\n")
> call pargr (xpix)
> call pargr (ypix)
> call pargstr (id)		# TMP
> 	}
> 	}
200c182,183
< entry	 qxfm_init (fda, fdb, map, a3, sys, ccd)
---
> 	if (file_list)
> 		call close (fd)
202,210d184
< # Iitialize the maps
< 	call gs_ingest (fda, map[1], map[2])
< 	call gs_ingest (fdb, map[3], map[4])
< 
< # set up the grating transform
< 	call gsetup (a3, sys)
< 
< # CCD: define the geometry of the mosaic
< 	call ccd_geom (ccd, sys, YES)
213a188
> 
248a224,267
> 
> 
> ##
> ## GEN_XFM: general transform of r[3] into another CS desribed by a; "forward"
> ## is YES/NO to describe if xform is into or ou-of CS
> ## Note that the appropriate operation (eg transmission, reflection) must be
> ## applied afterward
> ##
> 
> #procedure	gen_xfm (r, a, forward)
> 
> #double	r[3]
> #double	a[3,3]
> #int	forward
> 
> #double	rp[3]
> #int	i, j
> 
> #begin
> ## transform
> #	if (forward == YES) {
> #	    do i = 1, 3 {
> #		rp[i] = 0.
> #		do j = 1, 3 {
> #			rp[i] = rp[i] + a[i,j] * r[j]
> #		}
> #	    }
> #
> #	    do i = 1, 3
> #		r[i] = rp[i]
> #
> #	} else {
> #		
> #	    do i = 1, 3
> #		rp[i] = r[i]
> #
> #	    do i = 1, 3 {
> #		r[i] = 0.
> #		do j = 1, 3 {
> #			r[i] = r[i] + a[j,i] * rp[j]
> #		}
> #	    }
> #	}
> #end
